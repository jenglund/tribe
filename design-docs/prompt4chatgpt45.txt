I'm working on a web app called Tribe. The original idea was pitched by my partner, Albert, and he wanted to be able to take a list of restaurants (ideally from something like his "Want To Go" list on Google Maps, but because Google charges for access to their Maps API, that's an extremely low priority right now, and we're perfectly happy to have a solution that manages lists completely in-app) and filter on a variety of criteria (no mexican, not anything I've been to in the last 2 months (so the app would also let you track your history of times doing that thing on the list, and who you did it with each time), not anything my partner's been to in the last 2 months(soft requirement/light preference, we should be able to support this case to help lists be well-tailored but not so overly-restrictive as to generate empty result sets), needs a vegetarian option (preferably vegan), needs to be within 20 miles of {location} and be open for the next 90 minutes (or, if we _can_ do it/express it this way, "by the time we get there, we should still be able to have 60 minutes left"), etc), and then generate one or more random selections from the list, best matching that criteria, to present as results. They can either ask to just get 1 random result, or do KN+M results, where N is the number of people (so for a couple, N=2), K is the number of options you want them to be able to eliminate, and M is the number of choices you want to have the system decide between. So a classic example of this is the 5-3-1 selection system for couples: one suggests 5, the other nixes two, and the first nixes another two, leaving a single result. Except in this case, the system would provide the 5, and each participant would remove 2, leaving one result. That case would be K=2, N=2, M=1. If, instead, we set M=3, each participant would nix two selections, and they'd be left with 3 options, which then the system would randomly select from. We could have the system dynamically scale this based on the number of available results and the preferences of the participants. If there's only one result for me and Albert, that'd be K=0, N=2, M=1 to fit the result set. If there's 3 results, we might have a preference for M to be higher or K to be higher; let's say we each want to be able to eliminate at least 1 option (K>0), but no more than 3, and we prefer M be no more than 3 (M<=3). So the preference for K>0 and M<=3 can be satisfied by K=1, M=1 for us (me and Albert, N=2)).

I expanded this general idea out into the idea of an app that lets users sign up (Login via OAuth with Google (and maybe other providers level), or OTP-via-email (though email support is a low priority right now). No passwords.), and create "Tribes", which are groups of 1-8 Users (no more than 8, that's a good "max" for a LOT of different social events, even though we're heavily focused on the 2-user "couples in a romantic relationship that want to plan date nights, weekend activities, figure out what show to watch next, or decide on their next vacation), one to eight users that want to "do things together". Each user can create Lists, and those Lists can be owned by users (personal lists) or tribes (tribe lists); personal lists can only be edited by the owning user, but can be shared with other users and tribes. Tribe lists _can_ be shareable, but generally they're designed to be just for consumption by the tribe that owns them. They can be edited and contributed to by any member of the Tribe. Users can share their lists with a Tribe, and then everyone in the tribe can see that list, and use it in any "composed lists" they make (when trying to make a decision, you need to use at least one list, but you can include as many as you want and they'll be joined into one unified list for the decision-making processor to utilize).

That's a whole lot of ideas, but I want to help formulate it into a cohesive project and product plan around this core set of functionality and whatever other functionality is needed to make that experience of creating and sharing lists and pulling from lists to make decisions and whittling down options (if applicable) as reliable, stable, responsive, and enjoyable as possible. I want to develop a clear, comprehensive vision and roadmap for all the capabilities our system will need in order to support this core functionality, and I need to flesh out the ideas and have someone ask me questions about the cases I'm not thinking about, especially the ones that will have a major impact on the feel of the user experience. As I intend it to be an open-source project that anybody can run at home on their own system, I don't need it to be able to scale to thousands of users, a home solution might only have a couple users, or an enthusiast might host a small instance that could support them and their friends across a group of tribes, like maybe 100 users. But that's an exceptional and extreme case. So I don't need to over-engineer the scalability, a standard Postgres database should be plenty for our base needs. I want to develop project design documents for the repository giving guidance on best practices for development, especially development with AI models/agents, as the project will be designed with a lot of contributions from AI agents, and they work best with clear, comprehensive instructions about what you want and how you want it to do it.

I'm open to the solutions for the frontend and backend, but I prefer to use Go for the backend because it's a great combination of robust and user-friendly and highly performant, and it's also a language I'm using at work (Khan Academy), and it's nice to cultivate career skills even on personal projects! Khan Academy also uses React with TypeScript for their frontend, so I have a preference to do the same for this project as well. 

Help me brainstorm a thorough list of "user stories", things that users should be able to do on this app, Tribe, based on the description I've given, and also help me develop the high-level design/architecture for the system: we know we need a frontend which is talking with a backend which is talking with a database, so we need to plan out exactly everything that we need in our data model (what tables, and what columns/fields with what names and data types in each table?) so that we can properly configure out database and design our backend and frontend to understand and manipulate that data. We know we'll want to keep track of Users, Tribes, Lists (either a unified Lists structure/model/table, or possibly UserLists and TribeLists, as we may find they have substantially different requirements, or that it just works better for our design to have them separate rather than together), and have some way for lists to be shared, which means managing share data either within the list entity/row/model, or having some sort of ListShare entity (which might also split into UserListShare and TribeListShare, if we split the lists in the same way) that we can use to manage those sharing associations as individual things. If we want to be able to pull or sync list data from an external source, we'll want some sort of sync management system and state machine. I _think_ we want to be able to support soft-deletion of users and tribes and lists, but that's a guess/slight preference, not a requirement; I want to do what makes the most sense for the system I've described and what it needs, especially at the small sale it needs. I suspect, even at its small scale, it would benefit from a transaction management system for interacting with the database, and I think test-driven development is extremely effective, especially with AI agents, so I want to also have a plan for what kinds of functionality we'll want to be testing. (Clearly each API endpoint for the backend, we'll want to test every core functional case and any common/likely error cases, but what else? Are there any technical decisions that we need to make with our "probably Go and probably React" system in order to test it effectively? What else am I not thinking of when considering how to design this Tribe app and describe/plan how to develop and produce it?